import java.util.Random;


public class automataLib {
	//parent components
	Universe u;
	Main m;
	
	//for random functions
	Random r = new Random();
	
	//used to define neighbourhoods
	neighbours n; 
	
	//Global vars that hold the size of the world array
	int m_xSize;
	int m_ySize;
	
	int[][] instructions; //holds the actions to perform

	int[][] arTF_Ruleset;
	
	//constructor
	public automataLib(Main mm, int xSize, int ySize) {
		m = mm;
		n= new neighbours(0);
		m_xSize=xSize;
		m_ySize=ySize;
	}
	
	//takes a universe and the dataSources object for writing
	public void setTargetUni(Universe uu) {
		u=uu;
	}

	
	/*  = = = = = = = = = = = = = = = = = = = = 
	 *  = = = = = = = = = = = = = = = = = = = = 
	 * 		 	Value   Read/Write
	 *  = = = = = = = = = = = = = = = = = = = = 
	 *  = = = = = = = = = = = = = = = = = = = = 
	 */ 
	

	private void incrementMe(int xx, int yy, int zz){
		u.universe[xx][yy][zz]++;
	}
	
	//takes array co-ord, modification int, array param length, and returns wrap position.
    public int getWrap(int val, int mod, int len) { 
    	if((val+mod) % len < 0) {
    		return len+((val+mod) % len);
    	} else {
    		return (val+mod) % len;
    	}
    }

    //sets the specified cell to specified value
    public void placeval(int xx, int yy, int zz, int rand, int v) { 
    	if(r.nextInt(rand) == 0) {
    		u.universe[xx][yy][zz] = v;
    	}
    }
    
    public int getval(int xx, int yy, int zz, int rand, int v) { 
    	if(r.nextInt(rand) == 0) {
    		return u.universe[xx][yy][zz];
    	} else {
    		return 0;
    	}
    }
	
  //draws a line of val. Can be solid or rand, can be veto'd, optional overwrite with 0.    
   public void plcLn(int xx, int yy, int zz, int rand, int xnullx, int val, int veto, int placeO, int len, int blockSize, int toolVar) {
    	
    	if(r.nextInt(veto) == 0) { //chance to not write the line
		    for(int i = 1; i < ((len-xx)/2)+1; i++) {
		    	if(r.nextInt(rand) == 0) {
		    		placeval((xx+i)+((blockSize-1)/2), yy+((blockSize-1)/2), zz, 1, val+r.nextInt(toolVar));
		    	} else if(placeO > 0) {placeval((xx+i)+((blockSize-1)/2)-1, yy+((blockSize-1)/2), zz, 1, 0);}
		    }
    	}
    	
    }
    
    public void plcDataLn(int xx, int yy, int zz, int rand, int xnullx, int val, int veto, int placeO, int len, int blockSize, int toolVar, dataSources d, int softwrite) {
    	
    	if(r.nextInt(veto) == 0) { //chance to not write the line
		    for(int i = 1; i < ((len-xx)/2)+1; i++) {
		    	val = d.readNext();
		    	if(val != 0 || softwrite == 0) { //softwrite
			    	if(r.nextInt(rand) == 0) {
			    		placeval((xx+i)+((blockSize-1)/2), yy+((blockSize-1)/2), zz, 1, val+r.nextInt(toolVar));
			    	} else if(placeO > 0) {placeval((xx+i)+((blockSize-1)/2)-1, yy+((blockSize-1)/2), zz, 1, 0);}
		    	}
		    }
    	}
    	
    }
    
    
    public int[] getDataLn(int xx, int yy, int zz, int rand, int xnullx, int val, int veto, int placeO, int len, int blockSize, int toolVar) {
    	
    	int[] dataLine = new int[blockSize]; 
    	
    	if(r.nextInt(veto) == 0) { //chance to not get the line
		    for(int i = 1; i < ((len-xx)/2)+1; i++) {
		    	int dataInt = 0;
		    	
		    	if(r.nextInt(rand) == 0) {
		    		dataInt = getval((xx+i)+((blockSize-1)/2), yy+((blockSize-1)/2), zz, 1, val+r.nextInt(toolVar));
		    	} else if(placeO > 0) {dataInt = getval((xx+i)+((blockSize-1)/2)-1, yy+((blockSize-1)/2), zz, 1, 0);}
		    	
		    	dataLine[i-1]=dataInt;
		    }
    	}
    	
    	return dataLine;
    	
    }
    
    
    //with chance, set cell to val 
    public void seed(int xx, int yy, int zz, int rand, int xnullx, int val){ //chance to seed location
    	if(r.nextInt(rand) == 0) {placeval(xx, yy, zz, 1, val);}
    }
    
    //with chance, reset pixel to val, applies to whole universe
    public void seedAll(int rand, int val, int rndVar){
    	
    	for(int i = 0; i < u.universe.length; i++) {
			for (int j = 0; j < u.universe[0].length; j++) {
				for (int k = 0; k < u.universe[0][0].length; k++) {
			    	seed(i,j,k,rand,-1,val+r.nextInt(rndVar));
				}
			}
    	}
    } 
    
    //chance to seed every pixel on this layer
    public void seedZ(int rand, int zz, int val, int rndVar){ 
    	for(int i = 0; i < u.universe.length; i++) {
			for (int j = 0; j < u.universe[0].length; j++) {
			    seed(i,j,zz,rand, 0, val+r.nextInt(rndVar));
			}
    	}
    }

    
	/*  = = = = = = = = = = = = = = = = = = = = 
	 *  = = = = = = = = = = = = = = = = = = = = 
	 * 		 	Neighbourhood Checks
	 *  = = = = = = = = = = = = = = = = = = = = 
	 *  = = = = = = = = = = = = = = = = = = = = 
	 */ 

	
	//counts the neighbours not equal to val
	public int nbrCountNotVal(int xx, int yy, int zz, int val){
		int isOne = 0;

		for(int i = 0; i < n.NBH.length; i++) {
			if(u.snapshotUniverse[getWrap(xx, n.NBH[i][0], u.universe.length)][getWrap(yy, n.NBH[i][1], u.universe[0].length)][getWrap(zz, n.NBH[i][2], u.universe[0][0].length)] != val) {isOne++;}
		}
		
		return isOne;
	}
	 
	 
	
	/*  = = = = = = = = = = = = = = = = = = = = 
	 *  = = = = = = = = = = = = = = = = = = = = 
	 * 		 	Automata
	 *  = = = = = = = = = = = = = = = = = = = = 
	 *  = = = = = = = = = = = = = = = = = = = = 
	 */ 
	
	
	/*		Parameters
	 * Default: xx, yy, zz
	 * RandomProc
	 * Threshold
	 * 
	 * 
	 */

	
	public void internalAffairs(int xx, int yy, int zz){					
		n.setNbrhood(0);
		
		
		int t = nbrCountNotVal(xx,yy,zz,0);

		if (t == 2){incrementMe(xx,yy,zz);}
		if(t < 2 || t > 3){u.universe[xx][yy][zz] = 0;}
		
	}
	
	public void meekrochyp(int xx, int yy, int zz){					
		n.setNbrhood(0);
		

		int t = nbrCountNotVal(xx,yy,zz,0);

		if (t == 2){incrementMe(xx,yy,zz);}
		if(t < 2 || t > 4){u.universe[xx][yy][zz] = 0;}
		
	}
	

	public void exposeC(int xx, int yy, int zz){					
		n.setNbrhood(4);
		
		int cellCount = nbrCountNotVal(xx,yy,zz,0);
				
		if (cellCount > 0){u.universe[xx][yy][zz] = 0;}
		if (cellCount == 1){incrementMe(xx,yy,zz);}
	}
	
	public void exposeJ(int xx, int yy, int zz){					
		n.setNbrhood(4);
		if (nbrCountNotVal(xx,yy,zz,0) == 1){incrementMe(xx,yy,zz);}
	}
	
	public void diamondShuffle(int xx, int yy, int zz){					
		n.setNbrhood(0);

		int t = nbrCountNotVal(xx,yy,zz,0);

		if (t == 2){incrementMe(xx,yy,zz);}
		if(t < 2 || t > 3){u.universe[xx][yy][zz] = 0;}
		
	}

	public void goop(int xx, int yy, int zz){					
		n.setNbrhood(2);

		int t = nbrCountNotVal(xx,yy,zz,0);
		
		if (t < 2 || t > 4) {
			for(int i = 0; i < 5; i++) {
				u.universe[xx][yy][zz] = 0;
			}
		} 
		
		if (t == 3){incrementMe(xx,yy,zz);}
		
	}


	
	public void Wave(int xx, int yy, int zz, int rand){

		
		n.setNbrhood(0);
		
		if(u.snapshotUniverse[xx][yy][zz] > 1) {
			if(r.nextInt(rand) == 0) {
				for(int i = 0; i < n.NBH.length; i++) {
					if(u.snapshotUniverse[xx][yy][zz] > 4) {
						if(u.universe[getWrap(xx, n.NBH[i][0], u.universe.length)][getWrap(yy, n.NBH[i][1], u.universe[0].length)][getWrap(zz, n.NBH[i][2], u.universe[0][0].length)] < u.snapshotUniverse[xx][yy][zz]) {
							u.universe[getWrap(xx, n.NBH[i][0], u.universe.length)][getWrap(yy, n.NBH[i][1], u.universe[0].length)][getWrap(zz, n.NBH[i][2], u.universe[0][0].length)]+=1;
							u.universe[xx][yy][zz]-=1;
						}
						
					}
				}
			} 
		} else /*if(u.snapshotUniverse[xx][yy][zz] == 1)*/ {
			if(r.nextInt(rand) == 0) {
				int proc = r.nextInt(n.NBH.length);
				for(int i = 0; i < n.NBH.length; i++) {
					if(proc == i) {
						u.universe[getWrap(xx, n.NBH[i][0], u.universe.length)][getWrap(yy, n.NBH[i][1], u.universe[0].length)][getWrap(zz, n.NBH[i][2], u.universe[0][0].length)]+=u.snapshotUniverse[xx][yy][zz];
						u.universe[xx][yy][zz]-=u.snapshotUniverse[xx][yy][zz];
					}
				}
			}
		
		}

    }
	
	public void Brownian(int xx, int yy, int zz, int rand){

		if( r.nextInt(rand) == 0) {
			n.setNbrhood(6);
			
			int proc = r.nextInt(n.NBH.length);
			
			for(int i = 0; i < n.NBH.length; i++) {
				if(proc == i) {
					u.universe[getWrap(xx, n.NBH[i][0], u.universe.length)][getWrap(yy, n.NBH[i][1], u.universe[0].length)][getWrap(zz, n.NBH[i][2], u.universe[0][0].length)]+=u.snapshotUniverse[xx][yy][zz];
					u.universe[xx][yy][zz]-=u.snapshotUniverse[xx][yy][zz];
				}
			}
		}
    }


	public void rain(int xx, int yy, int zz){
		
		n.setNbrhood(7);
		
		int isOne = 0;

		for(int i = 0; i < n.NBH.length; i++) {
			if(u.snapshotUniverse[getWrap(xx, n.NBH[i][0], u.universe.length)][getWrap(yy, n.NBH[i][1], u.universe[0].length)][getWrap(zz, n.NBH[i][2], u.universe[0][0].length)] == 1) {isOne++;}
		}
		

		
		if(isOne == 1) {
			u.universe[xx][yy][zz] = 0;
		}

		if(isOne == 2) {incrementMe(xx,yy,zz);}


    }
	
	public void rain2(int xx, int yy, int zz){
		
		n.setNbrhood(8);
		
		int isOne = 0;

		for(int i = 0; i < n.NBH.length; i++) {
			if(u.snapshotUniverse[getWrap(xx, n.NBH[i][0], u.universe.length)][getWrap(yy, n.NBH[i][1], u.universe[0].length)][getWrap(zz, n.NBH[i][2], u.universe[0][0].length)] == 1) {isOne++;}
		}
		

		
		if(isOne != 2) {
			u.universe[xx][yy][zz] = 0;
		}

		if(isOne == 2) {incrementMe(xx,yy,zz);}


    }
	
	public void sierpenski(int xx, int yy, int zz){
		n.setNbrhood(9);
		
		int isOne = 0;

		for(int i = 0; i < n.NBH.length; i++) {
			if(u.universe[getWrap(xx, n.NBH[i][0], u.universe.length)][getWrap(yy, n.NBH[i][1], u.universe[0].length)][getWrap(zz, n.NBH[i][2], u.universe[0][0].length)] == 1) {isOne++;}

		}
		
		if(isOne == 1) {incrementMe(xx,yy,zz);} else {u.universe[xx][yy][zz] = 0;}

    }
	
	public void snapSierpenski(int xx, int yy, int zz){

		n.setNbrhood(9);
		int isOne = 0;

		for(int i = 0; i < n.NBH.length; i++) {

			if(u.snapshotUniverse[getWrap(xx, n.NBH[i][0], u.universe.length)][getWrap(yy, n.NBH[i][1], u.universe[0].length)][getWrap(zz, n.NBH[i][2], u.universe[0][0].length)] == 1) {isOne++;}
			
		}
		
		if(isOne == 1) {incrementMe(xx,yy,zz);} else {u.universe[xx][yy][zz] = 0;}

    }
	
	public void conway(int xx, int yy, int zz){

		n.setNbrhood(4);
		
		int isOne = nbrCountNotVal(xx,yy,zz,0);
		
		if(isOne < 2)  { u.universe[xx][yy][zz] = 0; }
		if(isOne > 3)  { u.universe[xx][yy][zz] = 0; }
		if(isOne == 3) { u.universe[xx][yy][zz]++; }

    }
	
	public void conway_twinPrime(int xx, int yy, int zz){
		int isOne=0;
		
		
		n.setNbrhood(3);
		isOne = nbrCountNotVal(xx,yy,zz,0);
		if(isOne >= 8)  { u.universe[xx][yy][zz] = 0; }
		if(isOne == 7) { u.universe[xx][yy][zz]++; }
		if(isOne <= 3)  { u.universe[xx][yy][zz] = 0; }
		
		n.setNbrhood(4);
		isOne = nbrCountNotVal(xx,yy,zz,0);
		if(isOne >= 4)  { u.universe[xx][yy][zz] = 0; }
		if(isOne == 3) { u.universe[xx][yy][zz]++; }
		if(isOne <= 1)  { u.universe[xx][yy][zz] = 0; }

    }
	
	public void PointToCircle(int xx, int yy, int zz){

		n.setNbrhood(10);
		int isOne = nbrCountNotVal(xx,yy,zz,0);
		
		if(isOne <= 3)  { u.universe[xx][yy][zz] = 0; }
		if(isOne >= 5)  { u.universe[xx][yy][zz] = 0; }
		if(isOne == 2 || isOne == 1)  {incrementMe(xx,yy,zz);}

	}
		
	public void rope(int xx, int yy, int zz){
		n.setNbrhood(12);
		
		int isOne = nbrCountNotVal(xx,yy,zz,0);
		
		if(isOne == 1)  { u.universe[xx][yy][zz] = 0; }
		if(isOne == 2)  {incrementMe(xx,yy,zz);}
		if(isOne > 2)  { u.universe[xx][yy][zz] = 0; }
	}
	
	
	
	
	public void arrayRule(int xx, int yy, int zz){

		n.setNbrhood(4);
		
		int isOne = nbrCountNotVal(xx,yy,zz,0);
		
		for(int i = 0; i < arTF_Ruleset.length; i++) {
			if(isOne >= arTF_Ruleset[i][0] && isOne <= arTF_Ruleset[i][1]) {
				u.universe[xx][yy][zz] = arTF_Ruleset[i][2];
			}
		}
	}
	
	public void arrayRuleIncrement(int xx, int yy, int zz){

		n.setNbrhood(4);
		
		int isOne = nbrCountNotVal(xx,yy,zz,0);
		
		for(int i = 0; i < arTF_Ruleset.length; i++) {
			if(isOne >= arTF_Ruleset[i][0] && isOne <= arTF_Ruleset[i][1]) {
				if(arTF_Ruleset[i][2] != 0) {
					if(arTF_Ruleset[i][3] != -1) {
						if(u.snapshotUniverse[xx][yy][zz] == arTF_Ruleset[i][3]) {u.universe[xx][yy][zz] = arTF_Ruleset[i][2];}
					} else {
						u.universe[xx][yy][zz] += arTF_Ruleset[i][2];
					} 
				} else {
					u.universe[xx][yy][zz]=0;
				}
			}
		}
	}
	
	public void ConwayExtendedRange(int xx, int yy, int zz){

		n.setNbrhood(3);
		
		
		int isOne = nbrCountNotVal(xx,yy,zz,0);
		
		
		if(isOne <= 3)  { u.universe[xx][yy][zz] = 0; }
		if(isOne == 4)  {incrementMe(xx,yy,zz);}
		if(isOne >= 5)  { u.universe[xx][yy][zz] = 0; }
	}
	
	public void ConwayExtendedRange2(int xx, int yy, int zz){

		n.setNbrhood(3);
		
		
		int isOne = nbrCountNotVal(xx,yy,zz,0);
		
		
		
		if(isOne <=0)  { u.universe[xx][yy][zz] = 0; }
		if(isOne == 5)  {incrementMe(xx,yy,zz);}
		if(isOne >= 7)  { u.universe[xx][yy][zz] = 0; }
		
	}
	
	public void ConwayExtendedRange3(int xx, int yy, int zz){

		n.setNbrhood(3);
		
		
		int sum = nbrCountNotVal(xx,yy,zz,0);
		
		if(sum <= 3)  { u.universe[xx][yy][zz] = 0; }
		if(sum == 5)  {incrementMe(xx,yy,zz);}
		if(sum > 5)  { u.universe[xx][yy][zz] = 0; }/**/
		
	}
	
	public void ConwayExtendedRange4(int xx, int yy, int zz){

		n.setNbrhood(3);
		
		
		int sum = nbrCountNotVal(xx,yy,zz,0);
	
		if(sum <= 1)  			 	{ u.universe[xx][yy][zz] = 0; } //min
		if(sum >= 10 && sum <= 11) 	{incrementMe(xx,yy,zz);} //balance
		if(sum >= 12 && sum <= 99) 	{ u.universe[xx][yy][zz] = 0; }	//max

	}
	
	public void ConwayExtendedRange5(int xx, int yy, int zz){

		n.setNbrhood(3);
		
		
		int sum = nbrCountNotVal(xx,yy,zz,0);

		if(sum <= 1)  			 	{ u.universe[xx][yy][zz] = 0; } //max
		if(sum >= 5 && sum <= 5) 	{incrementMe(xx,yy,zz);} //balance
		if(sum >= 6 && sum <= 99) 	{ u.universe[xx][yy][zz] = 0; }	//min
		
	}
	
	public void ConwayExtendedRange6(int xx, int yy, int zz){

		n.setNbrhood(3);
		
		
		int sum = nbrCountNotVal(xx,yy,zz,0);
		
		if(sum <= 5)  			 	{ u.universe[xx][yy][zz] = 0; } //max
		if(sum >= 13 && sum <= 18) 	{incrementMe(xx,yy,zz);} //balance
		if(sum >= 7 && sum <= 7) 	{ u.universe[xx][yy][zz] = 0; }	//min
		
	
	}
	
	public void ConwayExtendedRange7(int xx, int yy, int zz){

		n.setNbrhood(3);
		
		
		int sum = nbrCountNotVal(xx,yy,zz,0);

		if(sum <= 6)  { u.universe[xx][yy][zz] = 0; }
		if(sum == 8)  {incrementMe(xx,yy,zz);}
		if(sum == 12) {u.universe[xx][yy][zz] = 0;}
		
	}
	
	public void ConwayExtendedRange8(int xx, int yy, int zz){

		n.setNbrhood(3);
		
		
		int sum = nbrCountNotVal(xx,yy,zz,0);

		if(sum <= 5)  { u.universe[xx][yy][zz] = 0; }
		if(sum == 8)  {incrementMe(xx,yy,zz);}
		if(sum == 11) {u.universe[xx][yy][zz] = 0;}
		
	}
	
	public void ConwayExtendedRange9(int xx, int yy, int zz){

		n.setNbrhood(3);
		
		int sum = nbrCountNotVal(xx,yy,zz,0);
	
		if(sum <= 5)  { u.universe[xx][yy][zz] = 0; }
		if(sum == 6)  {incrementMe(xx,yy,zz);}
		if(sum == 7) {u.universe[xx][yy][zz] = 0;}
		
	}
	
	public void ConwayExtendedRange10(int xx, int yy, int zz){
		n.setNbrhood(3);
		int sum = nbrCountNotVal(xx,yy,zz,0);
	
		if(sum <= 1)  			 	{ u.universe[xx][yy][zz] = 0; } //min
		if(sum >= 10 && sum <= 11) 	{incrementMe(xx,yy,zz);} //balance
		if(sum >= 12 && sum <= 99) 	{ u.universe[xx][yy][zz] = 0; }	//max
		
		
		if(sum <= 7)  { u.universe[xx][yy][zz] = 0; }
		if(sum == 4)  {incrementMe(xx,yy,zz);}
		if(sum == 15) {u.universe[xx][yy][zz] = 0;}
		
	}
	
	public void ConwayExtendedRange11(int xx, int yy, int zz){

		n.setNbrhood(3);
		
		
		int sum = nbrCountNotVal(xx,yy,zz,0);
	
		if(sum <= 12)  { u.universe[xx][yy][zz] = 0; }
		if(sum < 13)  { u.universe[xx][yy][zz] = 0; }
		if(sum == 4)  {incrementMe(xx,yy,zz);}
		if(sum >= 13)  {incrementMe(xx,yy,zz);}
		
	}
	
	public void ConwayExtendedRange12(int xx, int yy, int zz){

		n.setNbrhood(3);
		
		int sum = nbrCountNotVal(xx,yy,zz,0);
	
		if(sum <= 12)  { u.universe[xx][yy][zz] = 0; }
		if(sum == 4)  {incrementMe(xx,yy,zz);}
		if(sum > 99)  { u.universe[xx][yy][zz] = 0; }
	}
	
	public void ConwayExtendedRange13(int xx, int yy, int zz){
		n.setNbrhood(3);
		
		
		int sum = nbrCountNotVal(xx,yy,zz,0);
	
		if(sum <= 8)  { u.universe[xx][yy][zz] = 0; }
		if(sum == 4)  {incrementMe(xx,yy,zz);}
		if(sum > 99)  { u.universe[xx][yy][zz] = 0; }
	}
	
	public void ConwayExtendedRange13_2(int xx, int yy, int zz){

		n.setNbrhood(3);
		
		
		int sum = nbrCountNotVal(xx,yy,zz,0);
	
		if(sum <= 6)  				{ u.universe[xx][yy][zz] = 0; }
		if(sum == 4)  				{incrementMe(xx,yy,zz);}
		if(sum >= 9 && sum <= 11)  	{ u.universe[xx][yy][zz] = 0; }
	}
	
	public void ConwayExtendedRange14(int xx, int yy, int zz){

		n.setNbrhood(3);
		
		int sum = nbrCountNotVal(xx,yy,zz,0);
		if(sum <= 7)  { u.universe[xx][yy][zz] = 0; }
		if(sum == 5)  {incrementMe(xx,yy,zz);}
		if(sum > 99)  { u.universe[xx][yy][zz] = 0; }
	}
	
	public void warts(int xx, int yy, int zz){

		n.setNbrhood(0);
		
		int isOne = nbrCountNotVal(xx,yy,zz,0);
		
		if(isOne > 0) {
			if(isOne <= 1)  { u.universe[xx][yy][zz] = 0; }
			if(isOne == 2)  {incrementMe(xx,yy,zz);}
			if(isOne >= 3)  { u.universe[xx][yy][zz] = 0; }
		}
		
	}
	
	public void Threads(int xx, int yy, int zz){
			n.setNbrhood(16);
			
			int isOne = nbrCountNotVal(xx,yy,zz,0);
			
			if(isOne > 0) {
				if(isOne <= 1)  { u.universe[xx][yy][zz] = 0; }
				if(isOne == 2) {incrementMe(xx,yy,zz);}
				if(isOne >= 3)  { u.universe[xx][yy][zz] = 0; }
			}
	}
	
	public void Inverse110(int xx, int yy, int zz){
		n.setNbrhood(11);
		
		int isOne = nbrCountNotVal(xx,yy,zz,0);
		
		if(isOne > 0) {
			//if(isOne == 0)  { u.universe[xx][yy][zz] = 0; }
			if(isOne == 1)  {incrementMe(xx,yy,zz);}
			if(isOne == 2)  { u.universe[xx][yy][zz] = 0; }
		}
		
		
	}
	
	public void Inverse110_2(int xx, int yy, int zz){
		n.setNbrhood(17);
		
		int isOne = nbrCountNotVal(xx,yy,zz,0);
		
		if(isOne > 0) {
			if(isOne <= 1)  { u.universe[xx][yy][zz] = 0; }
			if(isOne == 2)  {incrementMe(xx,yy,zz);}
			if(isOne >= 3)  { u.universe[xx][yy][zz] = 0; }
		}
	}
	
	public void Inverse110_leopard(int xx, int yy, int zz){
		n.setNbrhood(15);
		
		int isOne = nbrCountNotVal(xx,yy,zz,0);
		
		if(isOne > 0) {
			if(isOne <= 0)  { u.universe[xx][yy][zz] = 0; }
			if(isOne == 1)  {incrementMe(xx,yy,zz);}
			if(isOne >= 2)  { u.universe[xx][yy][zz] = 0; }
		}

	}

	
	public void actual3D(int xx, int yy, int zz){
		n.setNbrhood(24);
		int isOne = nbrCountNotVal(xx,yy,zz,0);

			if(isOne <= 2) { u.universe[xx][yy][zz] = 0;}
			if(isOne == 5){incrementMe(xx,yy,zz);}
			if(isOne >= 7) { u.universe[xx][yy][zz] = 0;} /*else { u.universe[xx][yy][zz] = 0; }*/

	}

	public void rule110(int xx, int yy, int zz){					
		n.setNbrhood(13);
		
		int isOne = nbrCountNotVal(xx,yy,zz,0);
		
		
		if(isOne > 0) {
			
			int[][] ar = new int[][] {{1,1,1,0},{1,1,0,1},{1,0,1,1},{1,0,0,0},{0,1,1,1},{0,1,0,1},{0,0,1,1},{0,0,0,0}};
			int ar2[] = new int[] {0,0,0};
	
			for(int i = 0; i < n.NBH.length; i++) {
				if(u.snapshotUniverse[getWrap(xx, n.NBH[i][0], u.universe.length)][getWrap(yy, n.NBH[i][1], u.universe[0].length)][getWrap(zz, n.NBH[i][2], u.universe[0][0].length)] == 1) {ar2[i]=1;} else {ar2[i]=0;}
			}
	
			int isThis = 0;
			for(int i = 0; i < ar.length; i++) {
				isThis = 0;
				for(int j = 0; j < n.NBH.length; j++) {
					if(ar[i][j] == ar2[j]) {isThis++;}
				}
				if(isThis == 3) {u.universe[xx][yy][zz] = ar[i][3];break;}
			}
			
			
		}
		

		//int t = totalistic(xx,yy,zz,1);

		/*if (t == 2){u.universe[xx][yy][zz] = 1;}
		if(t < 2 || t > 4){u.universe[xx][yy][zz] = 0;}*/
		
	}
	
	public void diffusion(int xx, int yy, int zz, int rand, int thresh){
		
		if(u.universe[xx][yy][zz] > thresh) {
			n.setNbrhood(22);
			
	
			for(int i = 0; i < n.NBH.length; i++) {
				u.universe[getWrap(xx, n.NBH[i][0], u.universe.length)][getWrap(yy, n.NBH[i][1], u.universe[0].length)][getWrap(zz, n.NBH[i][2], u.universe[0][0].length)]+=1;
				u.universe[xx][yy][zz]-=1;
			}
		}
		
	}

	
	

public void hex1(int xx, int yy, int zz){
	
	n.setNbrhood(21);
	
	int sum = nbrCountNotVal(xx, yy, zz, 0);
	
	if(sum <= 1)  { u.universe[xx][yy][zz] = 0; }
	if(sum >= 3)  {incrementMe(xx,yy,zz);}
	if(sum >= 5)  { u.universe[xx][yy][zz] = 0; }
	
	
}



		
		public void mapPrev(int xx, int yy, int zz, int val){
			
			n.setNbrhood(23);
			
			int sum = 0;
			sum = u.snapshotUniverse[getWrap(xx, n.NBH[0][0], u.universe.length)][getWrap(yy, n.NBH[0][1], u.universe[0].length)][getWrap(zz, n.NBH[0][2], u.universe[0][0].length)];
			
			if(sum == 1) {u.universe[xx][yy][zz]+=val;}
		}
	
	 
		
		public void LangtonsAnt(int xx, int yy, int zz){

			n.setNbrhood(0);
			
			if(u.snapshotUniverse[xx][yy][zz] < 0) {
				
				int block_memory = -1;
				int newDir = -1;
				int newSelf;

				//Get my true value (0-7):
				int direction_to_go = (Math.abs(u.snapshotUniverse[xx][yy][zz])-1)%8;
				
				//This cell was x before I was here
				if(direction_to_go >= 0 && direction_to_go < 4) 	{block_memory = 0;}
				if(direction_to_go >= 4 && direction_to_go < 8)		{block_memory = 1;}
				
				//My predecessor went direction (0-3):
				int dir = direction_to_go%4;
				
				//Set my future direction (Rotate)
				if(block_memory == 0) {		newDir = (dir+1)%4;			}
				if(block_memory == 1) {		newDir = ((dir+3)%4);		}
					
				//Flip this block's value
				if(block_memory == 0) {u.universe[xx][yy][zz] = 1;} //lows trail 1s
				if(block_memory == 1) {u.universe[xx][yy][zz] = 0;} //highs trail 0s
					
				//encode nbr's value & direction				
				//0-3 encodes 0; 4-7 encodes 1;
				int nbr = u.snapshotUniverse[getWrap(xx, n.NBH[newDir][0], u.universe.length)][getWrap(yy, n.NBH[newDir][1], u.universe[0].length)][getWrap(zz, n.NBH[newDir][2], u.universe[0][0].length)];

				if(nbr == 1) {newSelf = 4;} else {newSelf = 0;}
					
					
				//add direction info & make negative
				newSelf += newDir;
				newSelf = -newSelf;
				
				//set my new direction's neighbour to my encoded data 
				u.universe[getWrap(xx, n.NBH[newDir][0], u.universe.length)][getWrap(yy, n.NBH[newDir][1], u.universe[0].length)][getWrap(zz, n.NBH[newDir][2], u.universe[0][0].length)] = newSelf-1;
			
			}
		}
		
		public void CyclicDaemon(int xx, int yy, int zz){

			n.setNbrhood(0);

				
			int found = 0;
			int cyc = 12;
				
			for(int i = 0; i < n.NBH.length; i++) {
				if(u.snapshotUniverse[xx][yy][zz]%cyc == (u.snapshotUniverse[getWrap(xx, n.NBH[i][0], u.universe.length)][getWrap(yy, n.NBH[i][1], u.universe[0].length)][getWrap(zz, n.NBH[i][2], u.universe[0][0].length)]+(cyc-1))%cyc) {
					found++;
				}
			}
				
			if(found != 0) {
				u.universe[xx][yy][zz]=(u.universe[xx][yy][zz]+1)%cyc;
			} 
				
		}        
		
		
		public void traffic2(int xx, int yy, int zz){

			n.setNbrhood(11);
	
			if(u.snapshotUniverse[xx][yy][zz] == 1) {
				u.universe[xx][yy][zz] = -1;
			}
			if(u.snapshotUniverse[getWrap(xx, n.NBH[0][0], u.universe.length)][getWrap(yy, n.NBH[0][1], u.universe[0].length)][getWrap(zz, n.NBH[0][2], u.universe[0][0].length)] == 1) {
				if(u.snapshotUniverse[xx][yy][zz] == 0) {
					u.universe[xx][yy][zz] = -1;
				}
			}
			if(u.snapshotUniverse[getWrap(xx, n.NBH[0][0], u.universe.length)][getWrap(yy, n.NBH[0][1], u.universe[0].length)][getWrap(zz, n.NBH[0][2], u.universe[0][0].length)] == 0) {
				if(Math.abs(u.snapshotUniverse[xx][yy][zz]) == 1) {
					u.universe[xx][yy][zz] = 0;
				}
			}
			if(u.snapshotUniverse[xx][yy][zz] == -1) {
				u.universe[xx][yy][zz] = 1;
			}/**/
			
			
			if(u.snapshotUniverse[xx][yy][zz] == 2) {
				u.universe[xx][yy][zz] = -2;
			}
			if(u.snapshotUniverse[getWrap(xx, n.NBH[1][0], u.universe.length)][getWrap(yy, n.NBH[1][1], u.universe[0].length)][getWrap(zz, n.NBH[1][2], u.universe[0][0].length)] == 2) {
				if(u.snapshotUniverse[xx][yy][zz] == 0) {
					u.universe[xx][yy][zz] = -2;
				}
			}
			if(u.snapshotUniverse[getWrap(xx, n.NBH[1][0], u.universe.length)][getWrap(yy, n.NBH[1][1], u.universe[0].length)][getWrap(zz, n.NBH[1][2], u.universe[0][0].length)] == 0) {
				if(Math.abs(u.snapshotUniverse[xx][yy][zz]) == 2) {
					u.universe[xx][yy][zz] = 0;
				}
			}
			if(u.snapshotUniverse[xx][yy][zz] == -2) {
				u.universe[xx][yy][zz] = 2;
			}
			
				
		}
		
		public void traffic(int xx, int yy, int zz){

			n.setNbrhood(11);
		
			
			if(u.snapshotUniverse[xx][yy][zz] == 1) {
				u.universe[xx][yy][zz] = -1;
			}
			if(u.snapshotUniverse[getWrap(xx, n.NBH[0][0], u.universe.length)][getWrap(yy, n.NBH[0][1], u.universe[0].length)][getWrap(zz, n.NBH[0][2], u.universe[0][0].length)] == 1) {
				if(u.snapshotUniverse[xx][yy][zz] == 0) {
					u.universe[xx][yy][zz] = -1;
				}
			}
			if(u.snapshotUniverse[getWrap(xx, n.NBH[0][0], u.universe.length)][getWrap(yy, n.NBH[0][1], u.universe[0].length)][getWrap(zz, n.NBH[0][2], u.universe[0][0].length)] == 0) {
				if(u.snapshotUniverse[xx][yy][zz] == 1) {
					u.universe[xx][yy][zz] = 0;
				}
			}
			if(u.snapshotUniverse[xx][yy][zz] == -1) {
				u.universe[xx][yy][zz] = 1;
			}/**/
			
			
			if(u.snapshotUniverse[xx][yy][zz] == 2) {
				u.universe[xx][yy][zz] = -2;
			}
			if(u.snapshotUniverse[getWrap(xx, n.NBH[1][0], u.universe.length)][getWrap(yy, n.NBH[1][1], u.universe[0].length)][getWrap(zz, n.NBH[1][2], u.universe[0][0].length)] == 2) {
				if(u.snapshotUniverse[xx][yy][zz] == 0) {
					u.universe[xx][yy][zz] = -2;
				}
			}
			if(u.snapshotUniverse[getWrap(xx, n.NBH[1][0], u.universe.length)][getWrap(yy, n.NBH[1][1], u.universe[0].length)][getWrap(zz, n.NBH[1][2], u.universe[0][0].length)] == 0) {
				if(u.snapshotUniverse[xx][yy][zz] == 2) {
					u.universe[xx][yy][zz] = 0;
				}
			}
			if(u.snapshotUniverse[xx][yy][zz] == -2) {
				u.universe[xx][yy][zz] = 2;
			}/**/
			
			
				
		}
		
		
		public void platform(int xx, int yy, int zz){
			n.setNbrhood(28);
			
			if(u.snapshotUniverse[getWrap(xx, n.NBH[0][0], u.universe.length)][getWrap(yy, n.NBH[0][1], u.universe[0].length)][getWrap(zz, n.NBH[0][2], u.universe[0][0].length)] >= 1) {
				
				int cnt = nbrCountNotVal(xx, yy, zz, 0);
				
				if(cnt == 5){
					u.universe[xx][yy][zz]+=2;
				}
				
				if(cnt > 0){
					u.universe[xx][yy][zz]--;
				}
				
			}	
				
		}
		
	/////////////////////////////////////////////
	/////////Select Instruction to run///////////
	/////////////////////////////////////////////
																								  //Random, Threshold, Value
	public void readInstructions(int[] ins, int xx, int yy, int zz) {
		
		
		
		int insInstr = ins[0];
		int insZlay = ins[1];
		int insPar2 = ins[2];
		int insPar3 = ins[3];
		int insPar4 = ins[4];

		
		//		Utility functions / other
		if((insInstr == 11 || insInstr == 0) && (insZlay == zz || insZlay == -1)) {conway(xx, yy, zz 						);}
		if(insInstr == -1 && (insZlay == zz || insZlay == -1)) {seed(xx, yy, zz, 						insPar2, insPar3, insPar4);}
		if(insInstr == 5 && (insZlay == zz || insZlay == -1)) {mapPrev(xx,yy,zz,						insPar2);}
		if(insInstr == 68 && (insZlay == zz || insZlay == -1)) {platform(xx,yy,zz						);}
		if(insInstr == 85 && (insZlay == zz || insZlay == -1)) {exposeC(xx,yy,zz						);}
		if(insInstr == 86 && (insZlay == zz || insZlay == -1)) {exposeJ(xx,yy,zz						);}
		if(insInstr == 88 && (insZlay == zz || insZlay == -1)) {conway_twinPrime(xx,yy,zz				);}
		
		//1D / Single Point starter required
		if(insInstr == 6  && (insZlay == zz || insZlay == -1)) {sierpenski(xx, yy, zz 					);}
		if(insInstr == 9 && (insZlay == zz || insZlay == -1)) {snapSierpenski(xx,yy,zz 					);}
		if(insInstr == 10 && (insZlay == zz || insZlay == -1)) {hex1(xx,yy,zz							);}
		if(insInstr == 54 && (insZlay == zz || insZlay == -1)) {LangtonsAnt(xx,yy,zz					);}
				
		//		2D Neighbourhoods
		if((insInstr == 11 || insInstr == 0) && (insZlay == zz || insZlay == -1)) {conway(xx, yy, zz 	);}
		if(insInstr == 12 && (insZlay == zz || insZlay == -1)) {ConwayExtendedRange(xx, yy, zz 			);}
		if(insInstr == 13  && (insZlay == zz || insZlay == -1)) {ConwayExtendedRange2(xx, yy, zz 		);}
		if(insInstr == 55  && (insZlay == zz || insZlay == -1)) {ConwayExtendedRange3(xx, yy, zz 		);}
		if(insInstr == 56  && (insZlay == zz || insZlay == -1)) {ConwayExtendedRange4(xx, yy, zz 		);}
		if(insInstr == 57  && (insZlay == zz || insZlay == -1)) {ConwayExtendedRange5(xx, yy, zz 		);}
		if(insInstr == 58  && (insZlay == zz || insZlay == -1)) {ConwayExtendedRange6(xx, yy, zz 		);}
		if(insInstr == 59  && (insZlay == zz || insZlay == -1)) {ConwayExtendedRange7(xx, yy, zz 		);}
		if(insInstr == 60  && (insZlay == zz || insZlay == -1)) {ConwayExtendedRange8(xx, yy, zz 		);}
		if(insInstr == 61  && (insZlay == zz || insZlay == -1)) {ConwayExtendedRange9(xx, yy, zz 		);}
		if(insInstr == 62  && (insZlay == zz || insZlay == -1)) {ConwayExtendedRange10(xx, yy, zz 		);}
		if(insInstr == 63  && (insZlay == zz || insZlay == -1)) {ConwayExtendedRange11(xx, yy, zz 		);}
		if(insInstr == 64  && (insZlay == zz || insZlay == -1)) {ConwayExtendedRange12(xx, yy, zz 		);}
		if(insInstr == 65  && (insZlay == zz || insZlay == -1)) {ConwayExtendedRange13(xx, yy, zz 		);}
		if(insInstr == 70  && (insZlay == zz || insZlay == -1)) {ConwayExtendedRange13_2(xx, yy, zz 	);}
		if(insInstr == 66  && (insZlay == zz || insZlay == -1)) {ConwayExtendedRange14(xx, yy, zz 		);}
		if(insInstr == 14  && (insZlay == zz || insZlay == -1)) {rain2(xx,yy,zz							);}
		if(insInstr == 15  && (insZlay == zz || insZlay == -1)) {goop(xx,yy,zz							);}
		if(insInstr == 16 && (insZlay == zz || insZlay == -1)) {internalAffairs(xx,yy,zz				);}
		if(insInstr == 17 && (insZlay == zz || insZlay == -1)) {meekrochyp(xx,yy,zz						);}
		if(insInstr == 18 && (insZlay == zz || insZlay == -1)) {diamondShuffle(xx,yy,zz					);}
		if(insInstr == 19 && (insZlay == zz || insZlay == -1)) {rain(xx,yy,zz							);}
		if(insInstr == 20 && (insZlay == zz || insZlay == -1)) {warts(xx,yy,zz							);}
		if(insInstr == 21 && (insZlay == zz || insZlay == -1)) {Threads(xx,yy,zz 						);}
		if(insInstr == 23 && (insZlay == zz || insZlay == -1)) {Wave(xx,yy,zz, 							insPar2);}
		if(insInstr == 24 && (insZlay == zz || insZlay == -1)) {rope(xx,yy,zz 							);}
		if(insInstr == 25 && (insZlay == zz || insZlay == -1)) {Inverse110(xx,yy,zz 					);}
		if(insInstr == 26 && (insZlay == zz || insZlay == -1)) {Inverse110_2(xx,yy,zz 					);}
		if(insInstr == 27 && (insZlay == zz || insZlay == -1)) {Inverse110_leopard(xx,yy,zz 			);}
		if(insInstr == 28 && (insZlay == zz || insZlay == -1)) {PointToCircle(xx,yy,zz 					);}
		if(insInstr == 67 && (insZlay == zz || insZlay == -1)) {CyclicDaemon(xx,yy,zz 					);}

		//Rules that can have their rules customised
		if(insInstr == 89 && (insZlay == zz || insZlay == -1)) {arrayRuleIncrement(xx,yy,zz 			);}
		
		
		//3D Neighbourhoods
		if(insInstr == 48 && (insZlay == zz || insZlay == -1)) {diffusion(xx,yy,zz, 					insPar2, insPar3);}
		if(insInstr == 49 && (insZlay == zz || insZlay == -1)) {Brownian(xx,yy,zz, 						insPar2);}
		
		if(insInstr == 50 && (insZlay == zz || insZlay == -1)) {actual3D(xx,yy,zz						);}
		
		
		
		
		
		
		

	}

	
}
